
#          Copyright Ferdinand Majerech 2011-2012.
# Distributed under the Boost Software License, Version 1.0.
#    (See accompanying file LICENSE_1_0.txt or copy at
#          http://www.boost.org/LICENSE_1_0.txt)

# main()
snippet main
	void main( string[] args )
	{
		${1}
	}
snippet mainn
	void main()
	{
		${1}
	}
# Import
snippet imp
	import ${1:module};
	${2}
# Public import
snippet pubimp
	public import ${1:module};
	${2}
# if, else
snippet if
	if( ${1:/* condition */} )
	{
		${2}
	}
snippet ife
	if( ${1:/* condition */} )
	{
		${2}
	}
	else
	{
		${3}
	}
snippet else
	else
	{
		${1}
	}
snippet elif
	else if( ${1:/* condition */} )
	{
		${2}
	}
# switch
snippet switch
	switch( ${1:var} )
	{
		case ${2:value}:
			${3}
		break;
		default:
	}
snippet sw
	switch( ${1:var} )
	{
		case ${2:value}:
			${3}
		break;
		default:
	}
snippet case
	case ${1:value}:
		${2}
	break;
# ternary operator
snippet ter
	${3:/* condition */} ? ${2:a} : ${1:b}
# do while
snippet do
	do
	{
		${2}
	} while( ${1:/* condition */} );
# while
snippet while
	while( ${1:/* condition */} )
	{
		${2}
	}
snippet wh
	while( ${1:/* condition */} )
	{
		${2}
	}
# for
snippet for
	for( auto ${1:i} = ${2:0}; $1 ${3:<} ${4:count}; $1${5:++} )
	{
		${6}
	}
# foreach
snippet fore
	foreach( ${2:var}; ${1:iterable} )
	{
		${3}
	}
snippet forek
	foreach( ${3:key}, ${2:var}; ${1:iterable} )
	{
		${4}
	}
snippet forif
	foreach( ${3:var}; ${2:iterable} ) if ( ${1:/*condition*/} )
	{
		${4}
	}
# function
snippet fun
	${1:auto} ${2:function_name}( ${3:args} )
	{
		${4}
	}
snippet funn
	${1:auto} ${2:function_name}( ${3:args} )
	in
	{
		${4}
	}
	body
	{
		${5}
	}
snippet over
	override ${1:auto} ${2:function_name}( ${3:args} )
	{
		${4}
	}
snippet this
	this( ${1} )
	{
		${2}
	}
snippet ~this
	~this( ${1} )
	{
		${2}
	}
# contracts
snippet in
	in
	{
		assert( ${1:expr}, "${2:msg}" );
	}
	body
snippet out
	out
	{
		assert( ${1:expr}, "${2:msg}" );
	}
	body
snippet body
	body
	{
		${1}
	}
# delegate
snippet dg
	( ${1:args} ){ ${2:body}; }
snippet dgg
	{${1:body};}
# accessors
snippet get
	@property ${1:type} ${2:member_name}() const {return ${3:expr};}
snippet set
	@property void ${1:member_name}( ${2:type} rhs ){${3} = rhs;}
# signal
snippet signal
	mixin Signal!( ${1:args} ) ${2:name};
# alias
snippet al
	alias ${1:type} ${2:alias_type};
# mixin
snippet mix
	mixin ${1:mixed_in} ${2:name};
# scope
snippet scope
	scope( ${1:exit} )
	{
		${2}
	}
# scope(exit)
snippet exit
	scope( exit ) ${1};
	${2}
# scope(success)
snippet success
	scope( success ) ${1};
	${2}
# scope(failure)
snippet failure
	scope( failure ) ${1};
	${2}
# throw
snippet thr
	throw new ${2}Exception( "${1}" );
snippet throw
	throw new ${2}Exception( "${1}" );
# with
snippet with
	with( ${1} )
	{
		${2}
	}
# struct
snippet struct
	struct ${1:`Filename('$1', 'name')`}
	{
		private:
			${2://}
		public:
			${3://}
	}
	${4}
# class
snippet class
	class ${1:`Filename('$1', 'name')`}
	{
		private:
			${2://}
		public:
			${3://}
	}
	${4}
# interface
snippet interface
	interface ${1:name}
	{
		${2}
	}
# enum
snippet enum
	enum ${1:name}
	{
		${2}
	}
# version
snippet version
	version( ${1:version_name} )
	{
		${2}
	}
snippet debug
	debug
	{
		${1}
	}
# unittest
snippet unittest
	unittest
	{
		${1}
	}
snippet utest
	unittest
	{
		${1}
	}
# template
snippet template
	template ${1:name}( ${2:args} )
	{
		${3}
	}
# temp
snippet temp
	template ${1:name}( ${2:args} )
	{
		${3}
	}
# assert
snippet assert
	assert( ${1:condition}, "${2:error_msg}" );
snippet ass
	assert( ${1:condition}, "${2:error_msg}" );
snippet astodo
	assert( false, "TODO" );
	${1}
# exception
snippet except
	///${3}
	class ${2:Foo}Exception : ${1}Exception
	{
		public this( string msg, string file = __FILE__, int line = __LINE__ )
		{
			super( msg, file, line );
		}
	}
snippet exc
	///${3}
	class ${2:Foo}Exception : ${1}Exception
	{
		public this( string msg, string file = __FILE__, int line = __LINE__ )
		{
			super( msg, file, line );
		}
	}
snippet exception
	///${3}
	class ${2:Foo}Exception : ${1}Exception
	{
		public this( string msg, string file = __FILE__, int line = __LINE__ )
		{
			super( msg, file, line );
		}
	}
#associative arrays
snippet aa
	${1}[${2}] ${3};
snippet aaa
	${1}[${2}] ${3} = [
		${4}
	];
# Operators:
snippet opDispatch:
	${1} opDispatch( string s )()
	{
		${2};
	}
snippet opDis:
	${1} opDispatch( string s )()
	{
		${2};
	}
# Trivial shortcuts
snippet dis:
	@disable ${1};
snippet @dis:
	@disable ${1};
snippet pub
	public:
		${1}
snippet priv
	private:
		${1}
snippet prot
	protected:
		${1}
snippet pack
	package:
		${1}
snippet cast
	cast(${1}) ${2}
snippet ret
	return ${1};
snippet auto
	auto ${1} = ${2};
	${3}
snippet con
	const ${1}
snippet siz
	size_t ${1}
snippet sup
	super(${1});
snippet is
	is(${1})
snippet typeof
	typeof(${1})
# Phobos
snippet wr
	writeln( ${1} );
snippet enf
	enforce( ${1}, new ${2}Exception( ${3} ) );
snippet to
	to!${1}( ${2} )
snippet select
	select!${1}( ${2}, ${3} );
snippet max
	max( ${1}, ${2} )
snippet min
	min( ${1}, ${2} )
# Comments
snippet todo
	// TODO: ${1}
# DDoc
snippet doc
	/**
	 * ${1:description}
	 *
	 * ${2:long_description}
	 */
snippet fundoc
	/**
	 * ${1:description}
	 *
	 * Params:  ${4:param} = ${3:param_description}
	 *
	 * Returns: ${2:return_description}
	 */
snippet fdoc
	/**
	 * ${1:description}
	 *
	 * Params:  ${4:param} = ${3:param_description}
	 *
	 * Returns: ${2:return_description}
	 */
snippet fdoc2
	/**
	 * ${1:description}
	 *
	 * Params:  ${4:param} = ${3:param_description}
	 *          ${6:param} = ${5:param_description}
	 *
	 * Returns: ${2:return_description}
	 */
snippet fdoc3
	/**
	 * ${1:description}
	 *
	 * Params:  ${4:param} = ${3:param_description}
	 *          ${6:param} = ${5:param_description}
	 *          ${8:param} = ${7:param_description}
	 *
	 * Returns: ${2:return_description}
	 */
snippet fdoc4
	/**
	 * ${1:description}
	 *
	 * Params:  ${4:param} = ${3:param_description}
	 *          ${6:param} = ${5:param_description}
	 *          ${8:param} = ${7:param_description}
	 *          ${10:param} = ${9:param_description}
	 *
	 * Returns: ${2:return_description}
	 */
snippet Params
	Params:  ${2:param} = ${1:description}
snippet Return
	Returns: ${1}
snippet Returns
	Returns: ${1}
snippet example
	 * Examples:
	 * --------------------
	 * ${1}
	 * --------------------
# GPL
snippet gpl
	/*
	 * This program is free software; you can redistribute it and/or modify
	 * it under the terms of the GNU General Public License as published by
	 * the Free Software Foundation; either version 2 of the License, or
	 * (at your option) any later version.
	 *
	 * This program is distributed in the hope that it will be useful,
	 * but WITHOUT ANY WARRANTY; without even the implied warranty of
	 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	 * GNU General Public License for more details.
	 *
	 * You should have received a copy of the GNU General Public License
	 * along with this program; if not, write to the Free Software
	 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
	 *
	 * Copyright (C) ${1:Author}, `strftime("%Y")`
	 */
	
	${2}
# Boost
snippet boost
	//          Copyright ${1:Author} `strftime("%Y")`.
	// Distributed under the Boost Software License, Version 1.0.
	//    (See accompanying file LICENSE_1_0.txt or copy at
	//          http://www.boost.org/LICENSE_1_0.txt)

	${2}
# New module
snippet module
	module ${1}.`Filename('$1', 'name')`;

	${2}
snippet mod
	module ${1}.`Filename('$1', 'name')`;

	${2}
# TRY/CATCH/FINALLY
snippet tn
	throw new ${1}Exception( ${2:"error"} );
	${3}
snippet try
	try
	{
		${1:static assert( false );}
	}
snippet catch
	catch( ${1}Exception ${2:ex} )
	{
		${3:static assert( false, "$1Exception not handled" );}
	}
snippet finally
	finally
	{
		${1:static assert( false, "finally not implemented." );}
	}
snippet tc
	try
		${1:static assert( false )};
	catch(${2}Exception ${3:ex})
		${4:static assert( false )};
	${5}
snippet tcb
	try
	{
		${1:static assert( false );}
	}
	catch( ${2}Exception ${3:ex} )
	{
		${4:static assert( false );}
	}
	${5}
snippet tf
	try
		${1:static assert( false )};
	finally
		${2:static assert( false )};
	${3}
snippet tcf
	try
		${1:static assert( false )};
	catch( ${2}Exception ${3:ex} )
		${4:static assert( false )};
	finally
		${5:static assert( false )};
	${6}
snippet tcfb
	try
	{
		${1:static assert( false );}
	}
	catch( ${2}Exception ${3:ex} )
	{
		${4:static assert(false);}
	}
	finally
	{
		${5:static assert(false);}
	}
